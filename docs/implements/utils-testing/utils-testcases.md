# テストケース定義書: Obsidian Smart History ユーティリティ機能

## プロジェクト情報

- **プロジェクト名**: Obsidian Smart History
- **対象モジュール**: `src/utils/domainUtils.js`, `src/utils/piiSanitizer.js`
- **作成日**: 2026-01-22
- **フェーズ**: TDD TestCases（テストケース洗い出し）

---

## 📋 開発コンテキスト情報

### 🎯 現在のフェーズ・状況
- **プロジェクト名**: Obsidian Smart History
- **プロジェクト種別**: Chrome拡張機能（Manifest V3）
- **現在のTDDフェーズ**: TestCases（テストケース洗い出し）
- **前回の完了フェーズ**: なし（TDD初回実施）
- **今回の実行予定**: 既存機能のテストケース定義とテストフレームワークの選定

### 📄 要件・仕様情報
- **機能概要**: ブラウザの閲覧履歴をAI要約付きでObsidianに自動保存する拡張機能
- **主要機能**:
  1. スマート検出（滞在時間5秒以上、スクロール深度50%以上で自動記録）
  2. AI要約機能（Gemini API、OpenAI互換API対応）
  3. Obsidian連携（Local REST API経由でデイリーノートに保存）
  4. 手動記録機能（重複チェックなしで即座に記録）
  5. ドメインフィルター（ホワイトリスト/ブラックリスト、ワイルドカード対応）
  6. PII（個人情報）サニタイゼーション機能
  7. プライバシーモード（Local Only、Masked Cloud、Full Pipeline）

- **制約条件**:
  - Manifest V3準拠（Service Worker使用）
  - モジュールシステム（ES Modules）
  - セキュリティ: 個人情報のマスキング必須

### 🧪 テスト情報
- **予定テストケース総数**: 28個
  - domainUtils: 14個（正常系9、異常系5、境界値4）
  - piiSanitizer: 14個（正常系5、異常系4、境界値4、コメント例1）
- **テスト分類**: 正常系・異常系・境界値を網羅
- **実装済みテスト**: 0個（テストファイル未作成）
- **テスト成功率**: -（未実施）
- 🔴 **赤信号**: テストファイルが存在しない

### 🔧 技術・実装情報
- **使用言語**: JavaScript（ES2022+）
- **テストフレームワーク**: Jest（推奨）
- **利用可能ライブラリ**:
  - Chrome Extensions API（tabs, storage, scripting, notifications）
  - ES Modules
- **既存実装パターン**:
  - `src/utils/` にユーティリティ関数（domainUtils, piiSanitizer, logger, storage）
  - `src/background/` にバックグラウンド処理（service-worker, aiClient, obsidianClient）
  - `src/content/` にコンテンツスクリプト（extractor）
  - `src/popup/` にポップアップUI
- **命名規則**: camelCase関数、PascalCaseクラス、UPPER_CASE定数
- 🟡 **黄信号**: package.jsonが存在しないため、テストフレームワークの選定が必要

---

## 📦 開発言語・フレームワーク

### プログラミング言語
- **言語**: JavaScript (ES2022+)
- **言語選択の理由**:
  - 既存コードベースがJavaScriptで記述されている
  - Chrome拡張機能のエコシステムと完全互換
  - モジュールシステム（ES Modules）を活用
- **テストに適した機能**:
  - モダンなJavaScriptの非同期処理（async/await）
  - モジュールのインポート/エクスポート
  - 正規表現のテストが容易
- 🟢 **青信号**: 既存コードベースと完全一致

### テストフレームワーク
- **テストフレームワーク**: **Jest** (推奨)
- **フレームワーク選択の理由**:
  - Chrome拡張機能のテストに実績あり
  - モック機能が充実（chrome.storage, chrome.runtime等）
  - スナップショットテスト対応
  - カバレッジレポート標準装備
  - 設定が比較的シンプル
- **代替案**: Vitest（高速だがChrome API mockが要追加設定）
- **テスト実行環境**:
  - Node.js環境（jsdom使用）
  - Chrome拡張API用のmock/stubを使用
  - CIでの自動実行を想定
- 🟡 **黄信号**: package.json未作成のため、これから導入が必要

---

## 🧪 テストケース定義

### 1. `domainUtils.js` のテストケース

対象ファイル: `src/utils/domainUtils.js`

#### 1-1. 正常系テストケース

##### テスト1-1-1: extractDomain - 標準的なURLからドメインを抽出
- **テスト名**: 標準的なHTTP URLからドメインを正しく抽出できる
  - **何をテストするか**: extractDomain関数が標準的なHTTP URLからホスト名を正しく抽出する機能
  - **期待される動作**: URLオブジェクトを解析し、ホスト名部分のみを返す
- **入力値**: `"http://example.com/path/to/page"`
  - **入力データの意味**: 最も一般的なHTTP URLの形式（プロトコル、ドメイン、パス含む）
- **期待される結果**: `"example.com"`
  - **期待結果の理由**: ホスト名のみが抽出され、プロトコルやパスは除外されるべき
- **テストの目的**: 基本的なドメイン抽出機能の動作確認
  - **確認ポイント**: URL.hostnameが正しく取得できること
- 🟢 **青信号**: 既存実装（13-27行目）を直接参照

##### テスト1-1-2: extractDomain - wwwプレフィックス除去
- **テスト名**: www付きドメインからwwwを除去して抽出できる
  - **何をテストするか**: www.example.comをexample.comに正規化する機能
  - **期待される動作**: hostnameからwww.プレフィックスを削除する
- **入力値**: `"https://www.example.com/"`
  - **入力データの意味**: wwwサブドメイン付きのURL（一般的なウェブサイトの形式）
- **期待される結果**: `"example.com"`
  - **期待結果の理由**: www有無でドメインを統一するため（example.comとwww.example.comを同一視）
- **テストの目的**: ドメイン正規化機能の確認
  - **確認ポイント**: startsWith('www.')の判定とsubstring(4)による除去が正しく動作すること
- 🟢 **青信号**: 既存実装（18-21行目）を直接参照

##### テスト1-1-3: matchesPattern - 完全一致パターン
- **テスト名**: ワイルドカード無しパターンで完全一致を検出できる
  - **何をテストするか**: ワイルドカード無しの場合の大文字小文字を区別しない完全一致
  - **期待される動作**: 文字列の大文字小文字を無視して完全一致を判定
- **入力値**:
  - `domain: "example.com"`
  - `pattern: "example.com"`
  - **入力データの意味**: シンプルな完全一致ケース
- **期待される結果**: `true`
  - **期待結果の理由**: 完全に一致するドメインはtrueを返すべき
- **テストの目的**: 基本的なパターンマッチング機能の確認
  - **確認ポイント**: toLowerCase()による正規化と === による比較
- 🟢 **青信号**: 既存実装（46-47行目）を直接参照

##### テスト1-1-4: matchesPattern - ワイルドカードパターン（サブドメイン）
- **テスト名**: ワイルドカードパターンでサブドメインをマッチできる
  - **何をテストするか**: `*.example.com` パターンで `sub.example.com` をマッチさせる
  - **期待される動作**: ワイルドカードを正規表現に変換してマッチング
- **入力値**:
  - `domain: "sub.example.com"`
  - `pattern: "*.example.com"`
  - **入力データの意味**: サブドメインを含むドメインとワイルドカードパターン
- **期待される結果**: `true`
  - **期待結果の理由**: `*`は任意の文字列にマッチするため、`sub`がマッチする
- **テストの目的**: ワイルドカード機能の基本動作確認
  - **確認ポイント**: replace(/\*/g, '.*')による変換とRegExpマッチング
- 🟢 **青信号**: 既存実装（36-44行目）を直接参照

##### テスト1-1-5: isDomainInList - リスト内に存在するドメイン
- **テスト名**: ドメインリストに含まれるドメインを正しく検出できる
  - **何をテストするか**: 配列内のパターンと照合して含まれているかを判定
  - **期待される動作**: someメソッドでいずれかのパターンにマッチすればtrueを返す
- **入力値**:
  - `domain: "example.com"`
  - `domainList: ["example.com", "test.com"]`
  - **入力データの意味**: ホワイトリスト/ブラックリストの典型的な使用ケース
- **期待される結果**: `true`
  - **期待結果の理由**: リストの1番目にexample.comが含まれているため
- **テストの目的**: リストマッチング機能の基本確認
  - **確認ポイント**: Array.someとmatchesPatternの組み合わせ
- 🟢 **青信号**: 既存実装（56-62行目）を直接参照

##### テスト1-1-6: isValidDomain - 有効なドメイン形式
- **テスト名**: 標準的なドメイン形式を有効と判定できる
  - **何をテストするか**: 正規表現による基本的なドメイン形式の検証
  - **期待される動作**: [a-z0-9.-]の組み合わせで構成されたドメインを有効と判定
- **入力値**: `"example.com"`
  - **入力データの意味**: 最も標準的なドメイン形式
- **期待される結果**: `true`
  - **期待結果の理由**: RFC準拠の有効なドメイン形式のため
- **テストの目的**: ドメインバリデーションの基本機能確認
  - **確認ポイント**: 正規表現パターン（75行目）のマッチング
- 🟢 **青信号**: 既存実装（69-79行目）を直接参照

##### テスト1-1-7: isDomainAllowed - フィルター無効時の動作
- **テスト名**: ドメインフィルターが無効な場合は全てのドメインを許可する
  - **何をテストするか**: `mode === 'disabled'` の場合の早期リターン
  - **期待される動作**: 設定がdisabledの場合、ドメインチェックをスキップしてtrueを返す
- **入力値**:
  - `url: "https://any-domain.com"`
  - `settings: { domain_filter_mode: 'disabled' }`
  - **入力データの意味**: フィルター機能を使用しないケース
- **期待される結果**: `true`
  - **期待結果の理由**: フィルター無効時は全てのドメインを許可する仕様
- **テストの目的**: フィルター無効時の動作確認
  - **確認ポイント**: 早期リターン（91-93行目）の動作
- 🟢 **青信号**: 既存実装を直接参照、ただしchrome.storage.localのmock化が必要

##### テスト1-1-8: isDomainAllowed - ホワイトリストモードでの許可
- **テスト名**: ホワイトリストモードで登録済みドメインを許可する
  - **何をテストするか**: ホワイトリストに含まれるドメインのみtrueを返す機能
  - **期待される動作**: isDomainInListでホワイトリストと照合し、含まれていればtrueを返す
- **入力値**:
  - `url: "https://allowed.com/page"`
  - `settings: { domain_filter_mode: 'whitelist', domain_whitelist: ['allowed.com'] }`
  - **入力データの意味**: 企業での利用時など、特定ドメインのみ記録するケース
- **期待される結果**: `true`
  - **期待結果の理由**: ホワイトリストにallowed.comが登録されているため
- **テストの目的**: ホワイトリストフィルタリング機能の確認
  - **確認ポイント**: mode === 'whitelist' の分岐処理（103-105行目）
- 🟢 **青信号**: 既存実装を直接参照、chrome.storage.localのmock化が必要

##### テスト1-1-9: isDomainAllowed - ブラックリストモードでの拒否
- **テスト名**: ブラックリストモードで登録済みドメインを拒否する
  - **何をテストするか**: ブラックリストに含まれるドメインのみfalseを返す機能
  - **期待される動作**: isDomainInListでブラックリストと照合し、含まれていればfalseを返す
- **入力値**:
  - `url: "https://blocked.com/page"`
  - `settings: { domain_filter_mode: 'blacklist', domain_blacklist: ['blocked.com'] }`
  - **入力データの意味**: SNSなど特定ドメインを除外記録するケース
- **期待される結果**: `false`
  - **期待結果の理由**: ブラックリストにblocked.comが登録されているため
- **テストの目的**: ブラックリストフィルタリング機能の確認
  - **確認ポイント**: mode === 'blacklist' の分岐処理（106-108行目）と否定演算子
- 🟢 **青信号**: 既存実装を直接参照、chrome.storage.localのmock化が必要

#### 1-2. 異常系テストケース

##### テスト1-2-1: extractDomain - 不正なURL形式
- **テスト名**: 不正なURL文字列からドメイン抽出を試みた場合nullを返す
  - **エラーケースの概要**: URLコンストラクタがTypeErrorをthrowするケース
  - **エラー処理の重要性**: 不正入力に対する防御的プログラミング
- **入力値**: `"not-a-valid-url"`
  - **不正な理由**: プロトコルが無く、URLオブジェクトとして解析不可
  - **実際の発生シナリオ**: ユーザーが手動で不正な文字列を入力した場合
- **期待される結果**: `null`
  - **エラーメッセージの内容**: 戻り値がnullのみ（例外をthrowしない）
  - **システムの安全性**: try-catchでエラーハンドリングし、システムがクラッシュしない
- **テストの目的**: 不正入力に対する堅牢性の確認
  - **品質保証の観点**: 想定外の入力でもアプリケーションが停止しないことを保証
- 🟢 **青信号**: 既存実装（23-25行目）を直接参照

##### テスト1-2-2: matchesPattern - 空文字列パターン
- **テスト名**: 空文字列パターンでのマッチング動作を確認
  - **エラーケースの概要**: パターンが空文字列の場合の挙動
  - **エラー処理の重要性**: エッジケースでの予期しない動作を防ぐ
- **入力値**:
  - `domain: "example.com"`
  - `pattern: ""`
  - **不正な理由**: パターンとして意味を成さない
  - **実際の発生シナリオ**: 設定ファイルが破損した場合や、UI入力のバリデーション漏れ
- **期待される結果**: `false`
  - **エラーメッセージの内容**: 戻り値falseのみ
  - **システムの安全性**: 空パターンは何にもマッチしないと定義
- **テストの目的**: エッジケースでの安定動作確認
  - **品質保証の観点**: 境界値での一貫した動作を保証
- 🟡 **黄信号**: 既存実装では明示的な空文字列ハンドリングなし、実装挙動を確認する必要あり

##### テスト1-2-3: isDomainInList - 空配列の場合
- **テスト名**: ドメインリストが空配列の場合は常にfalseを返す
  - **エラーケースの概要**: リストが空の場合の早期リターン
  - **エラー処理の重要性**: 不要な処理をスキップし、パフォーマンスを向上
- **入力値**:
  - `domain: "example.com"`
  - `domainList: []`
  - **不正な理由**: 検索対象が存在しない
  - **実際の発生シナリオ**: 初回起動時や、リストが未設定の場合
- **期待される結果**: `false`
  - **エラーメッセージの内容**: 戻り値falseのみ
  - **システムの安全性**: 空配列でも例外が発生しない
- **テストの目的**: 空コレクションに対する堅牢性確認
  - **品質保証の観点**: 初期状態でもアプリケーションが正常動作することを保証
- 🟢 **青信号**: 既存実装（57-59行目）を直接参照

##### テスト1-2-4: isValidDomain - 特殊文字を含むドメイン
- **テスト名**: 特殊文字を含む不正なドメインを検出できる
  - **エラーケースの概要**: ドメイン名に使用不可能な文字が含まれる
  - **エラー処理の重要性**: セキュリティリスク（インジェクション攻撃）の防止
- **入力値**: `"example<script>.com"`
  - **不正な理由**: `<>`はドメイン名に使用不可
  - **実際の発生シナリオ**: XSS攻撃の試み、または不正な入力
- **期待される結果**: `false`
  - **エラーメッセージの内容**: 戻り値falseのみ
  - **システムの安全性**: 不正なドメインを拒否し、後続処理に渡さない
- **テストの目的**: セキュリティバリデーションの確認
  - **品質保証の観点**: 不正入力からシステムを保護することを保証
- 🟢 **青信号**: 既存実装（75行目の正規表現）を直接参照

##### テスト1-2-5: isDomainAllowed - 無効なURL（nullドメイン）
- **テスト名**: ドメイン抽出に失敗した場合はfalseを返す
  - **エラーケースの概要**: extractDomainがnullを返した場合の処理
  - **エラー処理の重要性**: 不正なURLに対する防御
- **入力値**: `url: "invalid-url"`
  - **不正な理由**: URL形式として不正
  - **実際の発生シナリオ**: ユーザーが手動入力した不正なURL
- **期待される結果**: `false`
  - **エラーメッセージの内容**: 戻り値falseのみ
  - **システムの安全性**: 不正なURLは許可しない
- **テストの目的**: エラーハンドリングの確認
  - **品質保証の観点**: 不正入力に対する防御的プログラミングの実装を確認
- 🟢 **青信号**: 既存実装（95-98行目）を直接参照

#### 1-3. 境界値テストケース

##### テスト1-3-1: matchesPattern - 複数ワイルドカード
- **テスト名**: 複数のワイルドカードを含むパターンを正しく処理できる
  - **境界値の意味**: ワイルドカードの数による処理の複雑さ
  - **境界値での動作保証**: 複数ワイルドカードでも正規表現変換が正しく動作
- **入力値**:
  - `domain: "sub.api.example.com"`
  - `pattern: "*.*.example.com"`
  - **境界値選択の根拠**: 複数階層のサブドメインを表現する最小ケース
  - **実際の使用場面**: マルチテナントSaaSなど、複雑なサブドメイン構造を持つサービス
- **期待される結果**: `true`
  - **境界での正確性**: 各ワイルドカードが独立して `.*` に変換され、正しくマッチ
  - **一貫した動作**: 単一ワイルドカードと同様の動作
- **テストの目的**: 複雑なパターンマッチングの確認
  - **堅牢性の確認**: 複雑な条件下でもロジックが破綻しないことを確認
- 🟡 **黄信号**: 既存実装では複数ワイルドカードの明示的なテストなし、動作確認が必要

##### テスト1-3-2: isValidDomain - 最大長ドメイン
- **テスト名**: RFC準拠の最大長ドメイン（253文字）を有効と判定できる
  - **境界値の意味**: ドメイン名の最大長（RFC 1035）
  - **境界値での動作保証**: 正規表現が長大な文字列でもタイムアウトしない
- **入力値**: 253文字のドメイン文字列（例: "a".repeat(63) + "." + ... で構成）
  - **境界値選択の根拠**: RFC 1035で規定された最大長
  - **実際の使用場面**: 長いサブドメインチェーンを持つ企業内システム
- **期待される結果**: `true`（ただし、正規表現が最大長を明示的にチェックしていない場合はtrue）
  - **境界での正確性**: 正規表現が長大な入力でもパフォーマンス劣化しない
  - **一貫した動作**: 長さに関わらず同じロジックで処理
- **テストの目的**: パフォーマンスと仕様準拠の確認
  - **堅牢性の確認**: 極端に長い入力でもシステムが応答することを確認
- 🟡 **黄信号**: 既存実装（75行目）では最大長チェックなし、RFCとの整合性要確認

##### テスト1-3-3: parseDomainList - 大量ドメイン（1000行）
- **テスト名**: 大量のドメインリスト（1000行）を正しくパースできる
  - **境界値の意味**: 実用的な最大ドメイン数
  - **境界値での動作保証**: 大量データでもパフォーマンス劣化しない
- **入力値**: 1000行のドメインリスト文字列
  - **境界値選択の根拠**: 企業の大規模ブラックリストを想定
  - **実際の使用場面**: セキュリティ部門が管理する広告・トラッキングドメインブロックリスト
- **期待される結果**: 1000要素の配列
  - **境界での正確性**: すべての行が正しくパースされる
  - **一貫した動作**: 少量リストと同様の動作
- **テストの目的**: スケーラビリティの確認
  - **堅牢性の確認**: 大量データでも応答時間が許容範囲内であることを確認
- 🟢 **青信号**: 既存実装（120-129行目）を直接参照、パフォーマンステストとして実施

##### テスト1-3-4: validateDomainList - 混在リスト（有効・無効ドメイン）
- **テスト名**: 有効と無効なドメインが混在するリストのエラーを正しく報告できる
  - **境界値の意味**: バリデーションエラーの数
  - **境界値での動作保証**: 複数エラーを漏れなく検出
- **入力値**: `["valid.com", "invalid<>.com", "another-valid.com", "bad domain"]`
  - **境界値選択の根拠**: 実際のユーザー入力で発生しうる混在ケース
  - **実際の使用場面**: ユーザーが手動でドメインリストを編集した場合
- **期待される結果**: エラー配列に2つのエラーメッセージ（2行目と4行目）
  - **境界での正確性**: すべての無効ドメインがエラーとして報告される
  - **一貫した動作**: エラーの有無に関わらず全行をチェック
- **テストの目的**: 包括的なバリデーションの確認
  - **堅牢性の確認**: 複数エラーが存在してもすべて検出できることを確認
- 🟢 **青信号**: 既存実装（136-151行目）を直接参照

---

### 2. `piiSanitizer.js` のテストケース

対象ファイル: `src/utils/piiSanitizer.js`

#### 2-1. 正常系テストケース

##### テスト2-1-1: sanitizeRegex - クレジットカード番号の検出・マスク
- **テスト名**: ハイフン区切りクレジットカード番号を検出してマスクできる
  - **何をテストするか**: 16桁のクレジットカード番号（4桁-4桁-4桁-4桁形式）の検出
  - **期待される動作**: 正規表現でマッチし、[MASKED:creditCard]に置換
- **入力値**: `"カード番号は 1234-5678-9012-3456 です"`
  - **入力データの意味**: 一般的なクレジットカード番号の表記形式
- **期待される結果**:
  - `text: "カード番号は [MASKED:creditCard] です"`
  - `maskedItems: [{ type: 'creditCard', original: '1234-5678-9012-3456' }]`
  - **期待結果の理由**: 個人情報保護のため、カード番号を完全にマスク
- **テストの目的**: 最も重要なPII（クレジットカード）の検出確認
  - **確認ポイント**: 正規表現（9行目）のマッチングとreplace処理
- 🟢 **青信号**: 既存実装を直接参照

##### テスト2-1-2: sanitizeRegex - マイナンバーの検出・マスク
- **テスト名**: 12桁のマイナンバーを検出してマスクできる
  - **何をテストするか**: 4桁-4桁-4桁形式のマイナンバー検出
  - **期待される動作**: 正規表現でマッチし、[MASKED:myNumber]に置換
- **入力値**: `"マイナンバー: 1234-5678-9012"`
  - **入力データの意味**: 日本固有の個人識別番号
- **期待される結果**:
  - `text: "マイナンバー: [MASKED:myNumber]"`
  - `maskedItems: [{ type: 'myNumber', original: '1234-5678-9012' }]`
  - **期待結果の理由**: 法的に保護が義務付けられた情報のため必須
- **テストの目的**: 日本特有のPII検出機能の確認
  - **確認ポイント**: myNumber正規表現（12行目）のマッチング
- 🟢 **青信号**: 既存実装を直接参照

##### テスト2-1-3: sanitizeRegex - メールアドレスの検出・マスク
- **テスト名**: 標準的なメールアドレスを検出してマスクできる
  - **何をテストするか**: RFC準拠の一般的なメールアドレス形式の検出
  - **期待される動作**: @を含む文字列を正規表現でマッチし、[MASKED:email]に置換
- **入力値**: `"連絡先: user@example.com"`
  - **入力データの意味**: 最も一般的なメールアドレス形式
- **期待される結果**:
  - `text: "連絡先: [MASKED:email]"`
  - `maskedItems: [{ type: 'email', original: 'user@example.com' }]`
  - **期待結果の理由**: メールアドレスは個人を特定可能な情報のため
- **テストの目的**: 頻出するPIIの検出確認
  - **確認ポイント**: email正規表現（20行目）のマッチング
- 🟢 **青信号**: 既存実装を直接参照

##### テスト2-1-4: sanitizeRegex - 日本の電話番号の検出・マスク
- **テスト名**: ハイフン付き日本の携帯電話番号を検出してマスクできる
  - **何をテストするか**: 090-xxxx-xxxx形式の携帯電話番号検出
  - **期待される動作**: 日本の電話番号パターンでマッチし、[MASKED:phoneJp]に置換
- **入力値**: `"電話: 090-1234-5678"`
  - **入力データの意味**: 日本の携帯電話番号の標準形式
- **期待される結果**:
  - `text: "電話: [MASKED:phoneJp]"`
  - `maskedItems: [{ type: 'phoneJp', original: '090-1234-5678' }]`
  - **期待結果の理由**: 電話番号は連絡先として個人情報に該当
- **テストの目的**: 地域固有のPII検出確認
  - **確認ポイント**: phoneJp正規表現（24行目）のマッチング
- 🟢 **青信号**: 既存実装を直接参照

##### テスト2-1-5: sanitizeRegex - 複数PIIの同時検出・マスク
- **テスト名**: 1つのテキスト内に複数種類のPIIが存在する場合にすべてマスクできる
  - **何をテストするか**: 異なる種類のPII（メール、電話、カード番号）の同時検出
  - **期待される動作**: for...ofループですべてのパターンを適用し、すべてマスク
- **入力値**: `"連絡先: user@example.com, 電話: 090-1234-5678, カード: 1234-5678-9012-3456"`
  - **入力データの意味**: 実際のフォーム送信データを想定
- **期待される結果**:
  - `text: "連絡先: [MASKED:email], 電話: [MASKED:phoneJp], カード: [MASKED:creditCard]"`
  - `maskedItems.length: 3`
  - **期待結果の理由**: すべてのPIIを漏れなく検出・マスク
- **テストの目的**: 包括的なPII検出機能の確認
  - **確認ポイント**: 複数パターンの順次適用（41-46行目）
- 🟢 **青信号**: 既存実装を直接参照

#### 2-2. 異常系テストケース

##### テスト2-2-1: sanitizeRegex - null入力
- **テスト名**: null入力に対して安全にエラーハンドリングできる
  - **エラーケースの概要**: 入力がnullの場合の早期リターン
  - **エラー処理の重要性**: TypeErrorを防ぎ、システムの安定性を保つ
- **入力値**: `null`
  - **不正な理由**: 文字列メソッドが使用できない
  - **実際の発生シナリオ**: コンテンツ抽出に失敗した場合
- **期待される結果**: `{ text: '', maskedItems: [] }`
  - **エラーメッセージの内容**: 空文字列と空配列を返す
  - **システムの安全性**: 例外をthrowせず、デフォルト値を返す
- **テストの目的**: nullセーフティの確認
  - **品質保証の観点**: 不正入力でもクラッシュしないことを保証
- 🟢 **青信号**: 既存実装（33-35行目）を直接参照

##### テスト2-2-2: sanitizeRegex - undefined入力
- **テスト名**: undefined入力に対して安全にエラーハンドリングできる
  - **エラーケースの概要**: 入力がundefinedの場合の早期リターン
  - **エラー処理の重要性**: 初期化されていない変数に対する防御
- **入力値**: `undefined`
  - **不正な理由**: 文字列メソッドが使用できない
  - **実際の発生シナリオ**: オプショナルパラメータが省略された場合
- **期待される結果**: `{ text: '', maskedItems: [] }`
  - **エラーメッセージの内容**: 空文字列と空配列を返す
  - **システムの安全性**: 例外をthrowせず、デフォルト値を返す
- **テストの目的**: undefined セーフティの確認
  - **品質保証の観点**: オプショナル引数の未指定に対応
- 🟢 **青信号**: 既存実装（33-35行目のtypeof チェック）を直接参照

##### テスト2-2-3: sanitizeRegex - 空文字列入力
- **テスト名**: 空文字列入力に対して正常に処理できる
  - **エラーケースの概要**: 有効な文字列だが内容が空のケース
  - **エラー処理の重要性**: エッジケースでの一貫した動作
- **入力値**: `""`
  - **不正な理由**: マスク対象が存在しない
  - **実際の発生シナリオ**: ページ内容が空のページを記録しようとした場合
- **期待される結果**: `{ text: '', maskedItems: [] }`
  - **エラーメッセージの内容**: そのまま空文字列と空配列を返す
  - **システムの安全性**: 正規表現マッチが0件でもエラーにならない
- **テストの目的**: 空入力に対する堅牢性確認
  - **品質保証の観点**: 最小入力でも正常動作することを確認
- 🟢 **青信号**: 既存実装（replace処理はマッチ0件でも安全）

##### テスト2-2-4: sanitizeRegex - 非文字列入力（数値）
- **テスト名**: 数値型入力に対して安全にエラーハンドリングできる
  - **エラーケースの概要**: 型チェックでstring以外を弾く
  - **エラー処理の重要性**: 型安全性の確保
- **入力値**: `12345`
  - **不正な理由**: typeof !== 'string'
  - **実際の発生シナリオ**: JavaScriptの型強制による意図しない入力
- **期待される結果**: `{ text: '', maskedItems: [] }`
  - **エラーメッセージの内容**: 空文字列と空配列を返す
  - **システムの安全性**: 型エラーを事前に防ぐ
- **テストの目的**: 型チェックの確認
  - **品質保証の観点**: 型安全性を保証
- 🟢 **青信号**: 既存実装（34行目のtypeofチェック）を直接参照

#### 2-3. 境界値・エッジケーステストケース

##### テスト2-3-1: sanitizeRegex - PIIの誤検知（正当な数字列）
- **テスト名**: PIIパターンに類似するが正当な数字列を誤検知しないか確認
  - **境界値の意味**: PIIと正当なデータの境界
  - **境界値での動作保証**: 過剰なマスキングを避ける
- **入力値**: `"商品コード: 1234567"` （7桁の数字だが銀行口座ではない文脈）
  - **境界値選択の根拠**: bankAccountパターン（7桁）との境界
  - **実際の使用場面**: ECサイトの商品コードや注文番号
- **期待される結果**: `{ text: "商品コード: [MASKED:bankAccount]", maskedItems: ... }`
  - **境界での正確性**: 現在の実装では7桁数字を銀行口座としてマスク（仕様通り）
  - **一貫した動作**: コメント「安全側に倒してマスク」（15-16行目）の通り
- **テストの目的**: 誤検知リスクの確認と仕様の明示
  - **堅牢性の確認**: セキュリティとユーザビリティのトレードオフを確認
- 🟡 **黄信号**: 誤検知は仕様として許容されているが、テストで挙動を明示する必要あり

##### テスト2-3-2: sanitizeRegex - 区切り文字バリエーション（スペース区切り）
- **テスト名**: ハイフンではなくスペース区切りのクレジットカード番号を検出できる
  - **境界値の意味**: 区切り文字の種類
  - **境界値での動作保証**: 複数の区切り形式に対応
- **入力値**: `"カード: 1234 5678 9012 3456"`
  - **境界値選択の根拠**: creditCardパターン（9行目）が`[-\s]?`でスペースもサポート
  - **実際の使用場面**: ユーザーがフォームに手入力する際のバリエーション
- **期待される結果**: `text: "カード: [MASKED:creditCard]"`
  - **境界での正確性**: スペース区切りでも正しくマッチ
  - **一貫した動作**: ハイフン区切りと同じ動作
- **テストの目的**: 柔軟なパターンマッチングの確認
  - **堅牢性の確認**: 入力形式のバリエーションに対応できることを確認
- 🟢 **青信号**: 既存実装（9行目の`[-\s]?`）を直接参照

##### テスト2-3-3: sanitizeRegex - 連続するPII（同一種別）
- **テスト名**: 同じテキスト内に同じ種類のPIIが複数存在する場合にすべてマスクできる
  - **境界値の意味**: 同一パターンのマッチ数
  - **境界値での動作保証**: グローバルフラグ（/g）が正しく動作
- **入力値**: `"メール1: user1@example.com, メール2: user2@example.com"`
  - **境界値選択の根拠**: replaceのグローバルマッチング動作の確認
  - **実際の使用場面**: フォームに複数の連絡先が記載されている場合
- **期待される結果**:
  - `text: "メール1: [MASKED:email], メール2: [MASKED:email]"`
  - `maskedItems.length: 2`
  - **境界での正確性**: すべてのマッチがマスクされる
  - **一貫した動作**: 1つ目も2つ目も同じようにマスク
- **テストの目的**: グローバルマッチングの確認
  - **堅牢性の確認**: 複数マッチでも漏れなく処理できることを確認
- 🟢 **青信号**: 既存実装（各正規表現の/gフラグ）を直接参照

##### テスト2-3-4: sanitizeRegex - 最大長テキスト（10,000文字）
- **テスト名**: 大量テキスト（10,000文字）に対しても正常に動作する
  - **境界値の意味**: 処理対象テキストの長さ
  - **境界値での動作保証**: 正規表現がReDoS攻撃に対して脆弱でないことを確認
- **入力値**: 10,000文字のテキスト（複数のPIIを含む）
  - **境界値選択の根拠**: extractor.jsが最大10,000文字に切り詰める仕様（39行目）に合わせる
  - **実際の使用場面**: 長文記事や技術ドキュメントのページ
- **期待される結果**: 処理時間が許容範囲内（例: 100ms以内）で完了し、すべてのPIIがマスクされる
  - **境界での正確性**: 長文でも検出漏れなし
  - **一貫した動作**: 短文と同じロジックで処理
- **テストの目的**: パフォーマンスとセキュリティの確認
  - **堅牢性の確認**: ReDoS攻撃に対する耐性を確認
- 🟡 **黄信号**: 正規表現のReDoS脆弱性テストは別途実施が望ましい

---

## 📝 テストケース実装時の日本語コメント例

以下は、実際にテストコードを書く際のコメント例です：

```javascript
describe('domainUtils', () => {
  describe('extractDomain', () => {
    test('標準的なHTTP URLからドメインを正しく抽出できる', () => {
      // 【テスト目的】: extractDomain関数の基本動作を確認
      // 【テスト内容】: 標準的なHTTP URLからホスト名のみを抽出する処理をテスト
      // 【期待される動作】: URLオブジェクトのhostnameプロパティが正しく取得される
      // 🟢 既存実装（domainUtils.js 13-27行目）を直接参照

      // 【テストデータ準備】: 最も一般的なHTTP URLの形式を用意
      // 【前提条件確認】: プロトコル、ドメイン、パスがすべて含まれていることを確認
      const url = 'http://example.com/path/to/page';

      // 【実際の処理実行】: extractDomain関数を呼び出し
      // 【処理内容】: URLをパースし、ホスト名部分を抽出する
      const result = extractDomain(url);

      // 【結果検証】: 期待値との一致を確認
      // 【期待値確認】: プロトコルとパスが除外され、ドメインのみが返されることを確認
      // 【品質保証】: URL解析ロジックが正確であることを保証
      expect(result).toBe('example.com'); // 【確認内容】: ホスト名のみが正しく抽出されることを確認
      // 🟢 この検証は既存実装に基づいており、推測なし
    });

    test('www付きドメインからwwwを除去して抽出できる', () => {
      // 【テスト目的】: www正規化機能の確認
      // 【テスト内容】: www.example.comがexample.comに正規化されることをテスト
      // 【期待される動作】: hostnameからwww.プレフィックスが削除される
      // 🟢 既存実装（domainUtils.js 18-21行目）を直接参照

      // 【テストデータ準備】: wwwサブドメイン付きのURLを用意
      const url = 'https://www.example.com/';

      // 【実際の処理実行】: extractDomain関数を呼び出し
      const result = extractDomain(url);

      // 【結果検証】: wwwが除去されていることを確認
      expect(result).toBe('example.com'); // 【確認内容】: wwwプレフィックスが正しく削除されることを確認
      // 🟢 この検証は既存実装に基づいており、推測なし
    });
  });
});
```

---

## 📊 品質判定

### ✅ 高品質: テストケース定義は実装準備完了

- **テストケース分類**: ✅ 正常系・異常系・境界値が網羅されている
  - domainUtils: 正常系9、異常系5、境界値4
  - piiSanitizer: 正常系5、異常系4、境界値4
- **期待値定義**: ✅ 各テストケースの期待値が明確
  - すべてのテストケースに具体的な入力値と期待結果を記載
  - エラーケースでもエラーメッセージ内容を明記
- **技術選択**: ✅ プログラミング言語・テストフレームワークが確定
  - 言語: JavaScript (ES2022+)
  - テストフレームワーク: Jest（Chrome拡張機能に最適）
- **実装可能性**: ✅ 現在の技術スタックで実現可能
  - 既存実装を直接参照したテストケース（🟢青信号）が大多数
  - 一部、動作確認が必要なケース（🟡黄信号）は実装時に検証予定

### 信頼性レベルサマリー

- 🟢 **青信号**: 24/28ケース（85.7%） - 既存実装を直接参照、推測なし
- 🟡 **黄信号**: 4/28ケース（14.3%） - 既存実装から妥当な推測
- 🔴 **赤信号**: 0/28ケース（0%） - 資料にない推測なし

---

## 🚀 次のステップ

### 次のお勧めステップ: `/tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

Redフェーズでは以下を実施します：

1. **テスト環境のセットアップ**
   - package.jsonの作成
   - Jestのインストールと設定
   - Chrome Extensions APIのmock設定

2. **失敗するテストの作成**
   - 上記で定義したテストケースを実装
   - まず失敗することを確認（Red）

3. **テスト実行の確認**
   - すべてのテストが適切に失敗することを確認
   - テストカバレッジの計測準備

---

## 📌 メモ

- テストケースは既存実装を基に作成しているため、リグレッションテストとして機能します
- Chrome拡張機能特有のAPI（chrome.storage.local等）は適切にmock化する必要があります
- パフォーマンステスト（大量データ、最大長テキスト）は別途実行環境を検討する必要があるかもしれません
- ReDoS脆弱性テストは専用のセキュリティテストツールの使用を検討してください
